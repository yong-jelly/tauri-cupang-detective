# Tauri + SQLite ë°ì´í„° ê´€ë¦¬ ì„¤ê³„ ê°€ì´ë“œ

> ì´ ë¬¸ì„œëŠ” ì˜¤í”„ë¼ì¸ ìš°ì„ ì˜ Tauri ë°ìŠ¤í¬í†± ì•±ì—ì„œ SQLiteë¥¼ ì‚¬ìš©í•œ ë°ì´í„° ê´€ë¦¬ì˜ ì„¤ê³„ ì›ì¹™ê³¼ í‘œì¤€ì„ ì •ì˜í•©ë‹ˆë‹¤.

## ëª©ì°¨

1. [ì„¤ê³„ ì² í•™](#1-ì„¤ê³„-ì² í•™)
2. [íŒŒì¼ ì €ì¥ ìœ„ì¹˜ì™€ ë„¤ì´ë°](#2-íŒŒì¼-ì €ì¥-ìœ„ì¹˜ì™€-ë„¤ì´ë°)
3. [ì•± ì„¤ì • êµ¬ì¡°](#3-ì•±-ì„¤ì •-êµ¬ì¡°)
4. [ìŠ¤í‚¤ë§ˆ ì„¤ê³„ ì›ì¹™](#4-ìŠ¤í‚¤ë§ˆ-ì„¤ê³„-ì›ì¹™)
5. [ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ](#5-ë§ˆì´ê·¸ë ˆì´ì…˜-ì „ëµ)
6. [UI/UX ì˜¨ë³´ë”© íë¦„](#6-uiux-ì˜¨ë³´ë”©-íë¦„)
7. [ë¹ˆ ìƒíƒœ(Empty State) ì²˜ë¦¬](#7-ë¹ˆ-ìƒíƒœempty-state-ì²˜ë¦¬)
8. [ë°±ì—…ê³¼ ë³µì›](#8-ë°±ì—…ê³¼-ë³µì›)
9. [Tauri ì»¤ë§¨ë“œ ì„¤ê³„](#9-tauri-ì»¤ë§¨ë“œ-ì„¤ê³„)
10. [ë³´ì•ˆ ê³ ë ¤ì‚¬í•­](#10-ë³´ì•ˆ-ê³ ë ¤ì‚¬í•­)

---

## 1. ì„¤ê³„ ì² í•™

### 1.1 ì˜¤í”„ë¼ì¸ ìš°ì„  (Offline-First)

- **ë„¤íŠ¸ì›Œí¬ ë…ë¦½ì„±**: ì¸í„°ë„· ì—°ê²° ì—†ì´ë„ ëª¨ë“  í•µì‹¬ ê¸°ëŠ¥ì´ ë™ì‘í•´ì•¼ í•©ë‹ˆë‹¤.
- **ë‹¨ì¼ íŒŒì¼ ì•„í‚¤í…ì²˜**: ëª¨ë“  ë°ì´í„°ëŠ” í•˜ë‚˜ì˜ SQLite íŒŒì¼ì— ì €ì¥ë©ë‹ˆë‹¤.
- **ì¦‰ê°ì  ì‘ë‹µ**: ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤ëŠ” ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì—†ì´ ì¦‰ê°ì ì¸ ì‘ë‹µì„ ì œê³µí•©ë‹ˆë‹¤.

### 1.2 ì‚¬ìš©ì ì†Œìœ  ë°ì´í„°

- **íˆ¬ëª…í•œ ì €ì¥ ìœ„ì¹˜**: ì‚¬ìš©ìê°€ ë°ì´í„° íŒŒì¼ì˜ ìœ„ì¹˜ë¥¼ ì•Œê³  ì§ì ‘ ê´€ë¦¬í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- **ì´ì‹ì„±**: íŒŒì¼ì„ ë‹¤ë¥¸ ì»´í“¨í„°ë¡œ ë³µì‚¬í•˜ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- **í”„ë¼ì´ë²„ì‹œ**: ë¯¼ê°í•œ ë°ì´í„°ê°€ ë¡œì»¬ì—ë§Œ ì €ì¥ë˜ì–´ í´ë¼ìš°ë“œ ìœ ì¶œ ìœ„í—˜ì´ ì—†ìŠµë‹ˆë‹¤.

### 1.3 ë‹¨ìˆœì„± ìš°ì„ 

- **ë‹¨ì¼ íŒŒì¼**: ì—¬ëŸ¬ íŒŒì¼ë¡œ ë¶„ì‚°í•˜ì§€ ì•Šê³  `.db` íŒŒì¼ í•˜ë‚˜ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
- **í‘œì¤€ í¬ë§·**: SQLiteëŠ” ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ì„ë² ë””ë“œ DBë¡œ, ë‹¤ì–‘í•œ ë„êµ¬ë¡œ ì—´ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **ìì²´ ì™„ê²°**: ì™¸ë¶€ DB ì„œë²„ë‚˜ ì„œë¹„ìŠ¤ ì˜ì¡´ ì—†ì´ ì•± ìì²´ë¡œ ì™„ê²°ë©ë‹ˆë‹¤.

---

## 2. íŒŒì¼ ì €ì¥ ìœ„ì¹˜ì™€ ë„¤ì´ë°

### 2.1 ê¸°ë³¸ ì €ì¥ ê²½ë¡œ

Tauriì˜ `app_data_dir()`ì„ í™œìš©í•˜ì—¬ OSë³„ í‘œì¤€ ê²½ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

| OS      | ê¸°ë³¸ ê²½ë¡œ                                              |
|---------|-------------------------------------------------------|
| macOS   | `~/Library/Application Support/{bundle-id}/`          |
| Windows | `C:\Users\{user}\AppData\Roaming\{bundle-id}\`        |
| Linux   | `~/.local/share/{bundle-id}/`                         |

**ê¶Œì¥ ë””ë ‰í† ë¦¬ êµ¬ì¡°:**

```
{app_data_dir}/
â”œâ”€â”€ config.json          # ì•± ì„¤ì • (DB ê²½ë¡œ ë“±)
â””â”€â”€ storage/
    â””â”€â”€ {app-name}.db    # ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼
```

### 2.2 ì‚¬ìš©ì ì ‘ê·¼ ê°€ëŠ¥ì„±

ì‚¬ìš©ìê°€ ë°ì´í„° íŒŒì¼ì— ì‰½ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡:

- **ì„¤ì • í™”ë©´ì—ì„œ í˜„ì¬ ê²½ë¡œ í‘œì‹œ**: íŒŒì¼ íƒìƒ‰ê¸°ë¡œ ë°”ë¡œ ì—´ ìˆ˜ ìˆëŠ” ë§í¬ ì œê³µ
- **ì»¤ìŠ¤í…€ ê²½ë¡œ ì§€ì›**: ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ìœ„ì¹˜ì— DB íŒŒì¼ì„ ì €ì¥í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©
- **ê¸°ì¡´ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°**: ë‹¤ë¥¸ ìœ„ì¹˜ì˜ ê¸°ì¡´ DB íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ê¸°ëŠ¥ ì œê³µ

```rust
// Rust (Tauri ë°±ì—”ë“œ) ì˜ˆì‹œ
fn default_db_path(app_handle: &AppHandle) -> Result<PathBuf, String> {
    let mut dir = app_handle
        .path()
        .app_data_dir()
        .map_err(|e| e.to_string())?;
    dir.push("storage");
    fs::create_dir_all(&dir).map_err(|e| e.to_string())?;
    Ok(dir.join("my-app.db"))  // ì•± ì´ë¦„.db
}
```

### 2.3 íŒŒì¼ ë„¤ì´ë° ê·œì¹™

#### ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼

```
{app-name}.db
```

ì˜ˆ: `tauti.db`, `receipt-tracker.db`

#### ì‚¬ìš©ìê°€ ìƒˆë¡œ ìƒì„±í•˜ëŠ” ê²½ìš°

íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ í¬í•¨í•˜ì—¬ êµ¬ë¶„:

```
{app-name}-{YYYYMMDD}-{HHmmss}.db
```

ì˜ˆ: `my-receipt-tracker-20251216-143052.db`

```typescript
// TypeScript ì˜ˆì‹œ
const formatTimestamp = (date: Date) => {
  const pad = (v: number, len = 2) => v.toString().padStart(len, "0");
  const y = date.getFullYear();
  const m = pad(date.getMonth() + 1);
  const d = pad(date.getDate());
  const hh = pad(date.getHours());
  const mm = pad(date.getMinutes());
  const ss = pad(date.getSeconds());
  return `${y}${m}${d}-${hh}${mm}${ss}`;
};

const fileName = `my-app-${formatTimestamp(new Date())}.db`;
```

#### ë°±ì—… íŒŒì¼

```
{ì›ë³¸íŒŒì¼ëª…}.backup-{YYYYMMDD}-{HHmmss}.db
```

ì˜ˆ: `tauti.backup-20251216-143052.db`

---

## 3. ì•± ì„¤ì • êµ¬ì¡°

### 3.1 ì„¤ì • íŒŒì¼ ë¶„ë¦¬

ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ê³¼ ì•± ì„¤ì • íŒŒì¼ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤:

- **config.json**: ì•± ì„¤ì • (DB ê²½ë¡œ, UI ì„¤ì • ë“±) - `app_data_dir` ë£¨íŠ¸ì— ì €ì¥
- **{app}.db**: ì‹¤ì œ ì‚¬ìš©ì ë°ì´í„° - ì‚¬ìš©ìê°€ ì§€ì •í•œ ê²½ë¡œ ë˜ëŠ” ê¸°ë³¸ ê²½ë¡œ

```json
// config.json ì˜ˆì‹œ
{
  "dbPath": "/Users/user/Documents/my-data.db",
  "theme": "light",
  "language": "ko"
}
```

### 3.2 DB ê²½ë¡œ ê´€ë¦¬ íë¦„

```
ì•± ì‹œì‘
   â”‚
   â–¼
config.jsonì—ì„œ dbPath ë¡œë“œ
   â”‚
   â”œâ”€â”€ dbPathê°€ ìˆê³  íŒŒì¼ ì¡´ì¬ â†’ DB ì—°ê²° â†’ ì •ìƒ ì‹œì‘
   â”‚
   â”œâ”€â”€ dbPathê°€ ìˆì§€ë§Œ íŒŒì¼ ì—†ìŒ â†’ ì˜¨ë³´ë”© í™”ë©´ (íŒŒì¼ ì„ íƒ/ìƒì„±)
   â”‚
   â””â”€â”€ dbPathê°€ ì—†ìŒ â†’ ì˜¨ë³´ë”© í™”ë©´ (íŒŒì¼ ì„ íƒ/ìƒì„±)
```

### 3.3 Rust êµ¬í˜„ íŒ¨í„´

```rust
// ì•± ìƒíƒœ ê´€ë¦¬
#[derive(Default)]
struct AppState {
    db_path: Mutex<Option<PathBuf>>,
}

// ì„¤ì • íŒŒì¼ ê²½ë¡œ
fn config_file(app_handle: &AppHandle) -> Result<PathBuf, String> {
    let mut dir = app_handle.path().app_data_dir().map_err(|e| e.to_string())?;
    fs::create_dir_all(&dir).map_err(|e| e.to_string())?;
    dir.push("config.json");
    Ok(dir)
}

// ì„¤ì •ì—ì„œ DB ê²½ë¡œ ë¡œë“œ
fn load_config_path(app_handle: &AppHandle) -> Result<Option<PathBuf>, String> {
    let file = config_file(app_handle)?;
    if !file.exists() {
        return Ok(None);
    }
    let data = fs::read_to_string(&file).map_err(|e| e.to_string())?;
    let value: Value = serde_json::from_str(&data).map_err(|e| e.to_string())?;
    if let Some(path_str) = value.get("dbPath").and_then(|v| v.as_str()) {
        if path_str.is_empty() {
            return Ok(None);
        }
        return Ok(Some(PathBuf::from(path_str)));
    }
    Ok(None)
}

// ì„¤ì •ì— DB ê²½ë¡œ ì €ì¥
fn save_config_path(app_handle: &AppHandle, path: &Path) -> Result<(), String> {
    let file = config_file(app_handle)?;
    let payload = json!({ "dbPath": path.to_string_lossy() });
    let serialized = serde_json::to_vec_pretty(&payload).map_err(|e| e.to_string())?;
    fs::write(&file, serialized).map_err(|e| e.to_string())
}
```

---

## 4. ìŠ¤í‚¤ë§ˆ ì„¤ê³„ ì›ì¹™

### 4.1 í…Œì´ë¸” ë„¤ì´ë° ì»¨ë²¤ì…˜

| êµ¬ë¶„ | ê·œì¹™ | ì˜ˆì‹œ |
|------|------|------|
| í…Œì´ë¸” | `tbl_` ì ‘ë‘ì‚¬ + snake_case | `tbl_user`, `tbl_payment` |
| ì¸ë±ìŠ¤ | `idx_` ì ‘ë‘ì‚¬ + í…Œì´ë¸”ëª…_ì»¬ëŸ¼ëª… | `idx_payment_user_id` |
| ìœ ë‹ˆí¬ ì¸ë±ìŠ¤ | `ux_` ì ‘ë‘ì‚¬ + í…Œì´ë¸”ëª…_ì»¬ëŸ¼ë“¤ | `ux_payment_user_pay` |
| ì™¸ë˜í‚¤ | ëª…ì‹œì  ì´ë¦„ ë¶ˆí•„ìš” (ì¸ë¼ì¸ ì •ì˜) | `FOREIGN KEY(user_id) REFERENCES tbl_user(id)` |

### 4.2 ê¸°ë³¸ í…Œì´ë¸” êµ¬ì¡°

ëª¨ë“  í…Œì´ë¸”ì— í¬í•¨í•´ì•¼ í•  ê³µí†µ ì»¬ëŸ¼:

```sql
-- ì‹œìŠ¤í…œ ì„¤ì • í…Œì´ë¸” (í•„ìˆ˜)
CREATE TABLE IF NOT EXISTS tbl_setting (
    id TEXT PRIMARY KEY,
    key TEXT UNIQUE NOT NULL,
    value TEXT,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**ìš©ë„:**
- ì•± ë²„ì „, ë§ˆì´ê·¸ë ˆì´ì…˜ ë²„ì „ ì¶”ì 
- ì˜¨ë³´ë”© ì™„ë£Œ ì—¬ë¶€ í”Œë˜ê·¸
- ê¸°íƒ€ ì•± ì„¤ì •ê°’

### 4.3 Primary Key ì „ëµ

| ìœ í˜• | ì‚¬ìš© ì‹œì  | ì˜ˆì‹œ |
|------|----------|------|
| UUID (TEXT) | ì™¸ë¶€ ì°¸ì¡°, ë™ê¸°í™” ê°€ëŠ¥ì„± | `id TEXT PRIMARY KEY` |
| AUTOINCREMENT | ìˆœì°¨ì  ë°ì´í„°, ë‚´ë¶€ìš© | `id INTEGER PRIMARY KEY AUTOINCREMENT` |

```sql
-- UUID ì‚¬ìš© ì˜ˆì‹œ (ì‚¬ìš©ì í…Œì´ë¸”)
CREATE TABLE IF NOT EXISTS tbl_user (
    id TEXT PRIMARY KEY,  -- UUID
    alias TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- AUTOINCREMENT ì‚¬ìš© ì˜ˆì‹œ (ê²°ì œ ë‚´ì—­)
CREATE TABLE IF NOT EXISTS tbl_payment (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    amount INTEGER NOT NULL,
    paid_at TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY(user_id) REFERENCES tbl_user(id) ON DELETE CASCADE
);
```

### 4.4 íƒ€ì„ìŠ¤íƒ¬í”„ í‘œì¤€

- **í¬ë§·**: ISO 8601 ë¬¸ìì—´ (`datetime('now')` = UTC)
- **í•„ìˆ˜ ì»¬ëŸ¼**: `created_at`, `updated_at`
- **ë¹„ì¦ˆë‹ˆìŠ¤ ì‹œê°„**: ë³„ë„ ì»¬ëŸ¼ìœ¼ë¡œ ê´€ë¦¬ (ì˜ˆ: `paid_at`, `ordered_at`)

```sql
-- ê¶Œì¥ íŒ¨í„´
created_at TEXT NOT NULL DEFAULT (datetime('now')),
updated_at TEXT NOT NULL DEFAULT (datetime('now'))
```

### 4.5 Foreign Keyì™€ CASCADE

```sql
PRAGMA foreign_keys = ON;  -- ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘ ì‹œ í™œì„±í™”

-- CASCADE ì‚­ì œ ì„¤ì •
FOREIGN KEY(user_id) REFERENCES tbl_user(id) ON DELETE CASCADE
```

**CASCADE ì‚¬ìš© ê°€ì´ë“œ:**
- `ON DELETE CASCADE`: ë¶€ëª¨ ì‚­ì œ ì‹œ ìì‹ë„ ì‚­ì œ (ê²°ì œ ë‚´ì—­ ë“±)
- `ON DELETE SET NULL`: ë¶€ëª¨ ì‚­ì œ ì‹œ ì°¸ì¡°ë¥¼ NULLë¡œ (ì„ íƒì  ê´€ê³„)
- ê¸°ë³¸: `ON DELETE RESTRICT` (ì‚­ì œ ì œí•œ)

### 4.6 ì¸ë±ìŠ¤ ì„¤ê³„

```sql
-- ë‹¨ì¼ ì»¬ëŸ¼ ì¸ë±ìŠ¤ (ì¡°íšŒ ë¹ˆë„ ë†’ì€ FK)
CREATE INDEX IF NOT EXISTS idx_payment_user_id ON tbl_payment(user_id);

-- ë³µí•© ìœ ë‹ˆí¬ ì¸ë±ìŠ¤ (ì¤‘ë³µ ë°©ì§€)
CREATE UNIQUE INDEX IF NOT EXISTS ux_payment_user_pay 
    ON tbl_payment (user_id, pay_id);

-- ë³µí•© ì¸ë±ìŠ¤ (ìì£¼ í•¨ê»˜ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼)
CREATE INDEX IF NOT EXISTS idx_payment_user_date 
    ON tbl_payment (user_id, paid_at);
```

### 4.7 ìŠ¤í‚¤ë§ˆ ì„¤ê³„ íŒ¨í„´

#### í—¤ë”-ë¼ì¸ íŒ¨í„´ (Header-Detail)

ì£¼ë¬¸/ê²°ì œì²˜ëŸ¼ 1:N ê´€ê³„ì˜ ë°ì´í„° êµ¬ì¡°:

```sql
-- í—¤ë” í…Œì´ë¸” (ì£¼ë¬¸)
CREATE TABLE IF NOT EXISTS tbl_order (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    order_id TEXT NOT NULL,
    total_amount INTEGER NOT NULL,
    ordered_at TEXT NOT NULL,
    -- ...
    FOREIGN KEY(user_id) REFERENCES tbl_user(id) ON DELETE CASCADE
);

-- ë¼ì¸ í…Œì´ë¸” (ì£¼ë¬¸ í•­ëª©)
CREATE TABLE IF NOT EXISTS tbl_order_item (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    order_id INTEGER NOT NULL,  -- tbl_order(id) FK
    line_no INTEGER NOT NULL,   -- ì£¼ë¬¸ ë‚´ ìˆœë²ˆ
    product_name TEXT NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    unit_price INTEGER,
    -- ...
    FOREIGN KEY(order_id) REFERENCES tbl_order(id) ON DELETE CASCADE
);

-- ìœ ë‹ˆí¬ ì¸ë±ìŠ¤ë¡œ ì¤‘ë³µ ë¼ì¸ ë°©ì§€
CREATE UNIQUE INDEX IF NOT EXISTS ux_order_item_order_line 
    ON tbl_order_item (order_id, line_no);
```

#### í‚¤-ê°’ íŒ¨í„´ (Key-Value)

ì¸ì¦ ì •ë³´, ì„¤ì •ê°’ ë“± ë™ì ì¸ ë°ì´í„°:

```sql
CREATE TABLE IF NOT EXISTS tbl_credential (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    key TEXT NOT NULL,        -- 'Cookie', 'Authorization' ë“±
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY(user_id) REFERENCES tbl_user(id) ON DELETE CASCADE,
    UNIQUE(user_id, key)      -- ì‚¬ìš©ìë‹¹ í‚¤ ìœ ì¼
);
```

#### íƒœê·¸ íŒ¨í„´ (Many-to-Many)

```sql
-- íƒœê·¸ í…Œì´ë¸” (ììœ  ì…ë ¥)
CREATE TABLE IF NOT EXISTS tbl_product_tag (
    id TEXT PRIMARY KEY,
    product_id TEXT NOT NULL,
    tag TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY(product_id) REFERENCES tbl_product(id) ON DELETE CASCADE,
    UNIQUE(product_id, tag)
);

CREATE INDEX IF NOT EXISTS idx_product_tag_tag ON tbl_product_tag(tag);
```

---

## 5. ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

### 5.1 ê¸°ë³¸ ì›ì¹™

- **ë©±ë“±ì„±**: ê°™ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•´ë„ ê°™ì€ ê²°ê³¼
- **ì ì§„ì  í™•ì¥**: ê¸°ì¡´ ë°ì´í„°ë¥¼ ë³´ì¡´í•˜ë©´ì„œ ìŠ¤í‚¤ë§ˆ í™•ì¥
- **ì•± ì‹œì‘ ì‹œ ìë™ ì‹¤í–‰**: ì‚¬ìš©ì ê°œì… ì—†ì´ ìµœì‹  ìŠ¤í‚¤ë§ˆ ìœ ì§€

### 5.2 CREATE IF NOT EXISTS íŒ¨í„´

í…Œì´ë¸” ìƒì„±ì€ í•­ìƒ `IF NOT EXISTS`ë¥¼ ì‚¬ìš©:

```sql
CREATE TABLE IF NOT EXISTS tbl_setting (
    id TEXT PRIMARY KEY,
    key TEXT UNIQUE NOT NULL,
    value TEXT,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_setting_key ON tbl_setting(key);
```

### 5.3 ALTER TABLE ë§ˆì´ê·¸ë ˆì´ì…˜

ê¸°ì¡´ í…Œì´ë¸”ì— ì»¬ëŸ¼ ì¶”ê°€ ì‹œ:

```rust
fn migrate_add_columns(conn: &Connection) -> Result<(), String> {
    // ì¶”ê°€í•  ì»¬ëŸ¼ ëª©ë¡
    let new_columns = vec![
        ("paid_at", "TEXT"),
        ("discount_amount", "INTEGER DEFAULT 0"),
    ];

    for (col_name, col_type) in &new_columns {
        let sql = format!(
            "ALTER TABLE tbl_payment ADD COLUMN {} {}",
            col_name, col_type
        );
        // ì»¬ëŸ¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ë§Œ ë¬´ì‹œ
        let _ = conn.execute(&sql, []);
    }

    Ok(())
}
```

### 5.4 ì‹œë“œ ë°ì´í„°

ê¸°ë³¸ê°’ì´ í•„ìš”í•œ ë§ˆìŠ¤í„° ë°ì´í„°:

```rust
fn seed_default_categories(conn: &Connection) -> Result<(), String> {
    let default_categories = vec![
        ("cat_food", "ì‹í’ˆ/ìŒë£Œ", "#ef4444"),
        ("cat_fashion", "ì˜ë¥˜/íŒ¨ì…˜", "#f97316"),
        ("cat_electronics", "ì „ìì œí’ˆ", "#3b82f6"),
    ];

    for (id, name, color) in default_categories {
        // INSERT OR IGNOREë¡œ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë¬´ì‹œ
        conn.execute(
            "INSERT OR IGNORE INTO tbl_category (id, name, color) VALUES (?1, ?2, ?3)",
            rusqlite::params![id, name, color],
        )
        .map_err(|e| e.to_string())?;
    }

    Ok(())
}
```

### 5.5 ë²„ì „ ê¸°ë°˜ ë§ˆì´ê·¸ë ˆì´ì…˜

ë³µì¡í•œ ì•±ì—ì„œëŠ” ë²„ì „ ë²ˆí˜¸ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì¶”ì :

```sql
-- tbl_settingì— ë§ˆì´ê·¸ë ˆì´ì…˜ ë²„ì „ ì €ì¥
INSERT OR REPLACE INTO tbl_setting (id, key, value, updated_at)
VALUES ('migration', 'schema_version', '3', datetime('now'));
```

```rust
fn run_migrations(conn: &Connection) -> Result<(), String> {
    let current_version = get_schema_version(conn)?;
    
    if current_version < 1 {
        run_migration_v1(conn)?;
    }
    if current_version < 2 {
        run_migration_v2(conn)?;
    }
    if current_version < 3 {
        run_migration_v3(conn)?;
    }
    
    set_schema_version(conn, 3)?;
    Ok(())
}
```

---

## 6. UI/UX ì˜¨ë³´ë”© íë¦„

### 6.1 ìƒíƒœ ê¸°ë°˜ ë¼ìš°íŒ…

ì•± ì‹œì‘ ì‹œ ìƒíƒœì— ë”°ë¼ ì ì ˆí•œ í™”ë©´ìœ¼ë¡œ ì•ˆë‚´:

```
ì•± ì‹œì‘
   â”‚
   â–¼
DB ìƒíƒœ í™•ì¸ (get_db_status)
   â”‚
   â”œâ”€â”€ configured=false || exists=false
   â”‚   â””â”€â”€ [DB ì„¤ì • ì˜¨ë³´ë”©] â†’ DB ì„ íƒ/ìƒì„±
   â”‚
   â”œâ”€â”€ configured=true && exists=true
   â”‚   â”‚
   â”‚   â–¼
   â”‚   ì‚¬ìš©ì ì¡´ì¬ í™•ì¸ (has_users)
   â”‚   â”‚
   â”‚   â”œâ”€â”€ hasUsers=false
   â”‚   â”‚   â””â”€â”€ [ê³„ì • ì˜¨ë³´ë”©] â†’ ì²« ê³„ì • ë“±ë¡
   â”‚   â”‚
   â”‚   â””â”€â”€ hasUsers=true
   â”‚       â””â”€â”€ [ë©”ì¸ í™”ë©´] â†’ ì •ìƒ ì‚¬ìš©
   â”‚
   â””â”€â”€ ì—ëŸ¬
       â””â”€â”€ [ì—ëŸ¬ í™”ë©´] â†’ ì¬ì‹œë„/ë¬¸ì˜
```

### 6.2 DB ì„¤ì • ì˜¨ë³´ë”© í™”ë©´

```typescript
// React ì˜ˆì‹œ
const DBOnboarding = ({ onComplete }) => {
  const [busyAction, setBusyAction] = useState<"init" | "load" | null>(null);
  
  // ê¸°ì¡´ DB íŒŒì¼ ì„ íƒ
  const selectExistingFile = async () => {
    setBusyAction("load");
    const selected = await open({
      multiple: false,
      filters: [
        { name: "SQLite DB", extensions: ["db", "sqlite", "sqlite3"] },
        { name: "All Files", extensions: ["*"] },
      ],
    });
    if (selected) {
      const result = await invoke("load_existing_db", { path: selected });
      onComplete(result);
    }
    setBusyAction(null);
  };
  
  // ìƒˆ DB ìƒì„±
  const createNewDatabase = async () => {
    setBusyAction("init");
    const directory = await open({
      directory: true,
      title: "ìƒˆ DBë¥¼ ì €ì¥í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”",
    });
    if (directory) {
      const fileName = `my-app-${formatTimestamp(new Date())}.db`;
      const fullPath = await join(directory, fileName);
      const result = await invoke("init_db", { path: fullPath });
      onComplete(result);
    }
    setBusyAction(null);
  };
  
  return (
    <div>
      <h1>ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •</h1>
      <p>ì•±ì€ SQLite íŒŒì¼ í•˜ë‚˜ë¡œ ëª¨ë“  ë°ì´í„°ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.</p>
      <button onClick={selectExistingFile} disabled={busyAction === "load"}>
        ê¸°ì¡´ DB íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
      </button>
      <button onClick={createNewDatabase} disabled={busyAction === "init"}>
        ìƒˆ DB ë§Œë“¤ê¸°
      </button>
    </div>
  );
};
```

### 6.3 ê³„ì •/ë°ì´í„° ì˜¨ë³´ë”©

DBê°€ ì¤€ë¹„ëœ í›„, í•µì‹¬ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì¶”ê°€ ì˜¨ë³´ë”©:

```typescript
const AppRouter = () => {
  const [dbStatus, setDbStatus] = useState<DbStatus | null>(null);
  const [hasUsers, setHasUsers] = useState<boolean | null>(null);
  
  // DB ë¯¸ì„¤ì •
  if (!dbStatus?.configured || !dbStatus?.exists) {
    return <DBOnboarding onComplete={handleDbReady} />;
  }
  
  // ì‚¬ìš©ì ì—†ìŒ
  if (hasUsers === false) {
    return <AccountOnboarding onComplete={handleAccountCreated} />;
  }
  
  // ì •ìƒ í™”ë©´
  return <MainApp />;
};
```

### 6.4 ë‹¨ê³„ë³„ ì˜¨ë³´ë”© íŒ¨í„´

ë³µì¡í•œ ì„¤ì •ì€ ë‹¨ê³„ë¡œ ë¶„ë¦¬:

```typescript
type Step = "provider" | "alias" | "verification" | "success";

const AccountOnboarding = ({ onComplete }) => {
  const [step, setStep] = useState<Step>("provider");
  const [formData, setFormData] = useState({
    provider: null,
    alias: "",
    credentials: null,
  });
  
  return (
    <div>
      {step === "provider" && (
        <ProviderSelect onSelect={(p) => {
          setFormData(prev => ({ ...prev, provider: p }));
          setStep("alias");
        }} />
      )}
      {step === "alias" && (
        <AliasInput 
          onBack={() => setStep("provider")}
          onNext={(alias) => {
            setFormData(prev => ({ ...prev, alias }));
            setStep("verification");
          }} 
        />
      )}
      {step === "verification" && (
        <CredentialVerify 
          onBack={() => setStep("alias")}
          onSuccess={(creds) => {
            // ì €ì¥ í›„ ì™„ë£Œ
            saveAccount(formData.provider, formData.alias, creds);
            setStep("success");
          }}
        />
      )}
      {step === "success" && (
        <SuccessMessage onContinue={onComplete} />
      )}
    </div>
  );
};
```

---

## 7. ë¹ˆ ìƒíƒœ(Empty State) ì²˜ë¦¬

### 7.1 ì„¤ê³„ ì›ì¹™

- **ëª…í™•í•œ ì•ˆë‚´**: ì™œ ë°ì´í„°ê°€ ì—†ëŠ”ì§€, ì–´ë–»ê²Œ ì±„ìš¸ ìˆ˜ ìˆëŠ”ì§€ ì„¤ëª…
- **í–‰ë™ ìœ ë„**: ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•  ìˆ˜ ìˆëŠ” ë²„íŠ¼/ë§í¬ ì œê³µ
- **ê¸ì •ì  í†¤**: ë¹ˆ ìƒíƒœë¥¼ ì—ëŸ¬ê°€ ì•„ë‹Œ ì‹œì‘ì ìœ¼ë¡œ í‘œí˜„

### 7.2 ê³µí†µ Empty State ì»´í¬ë„ŒíŠ¸

```typescript
interface EmptyStateProps {
  icon?: React.ReactNode;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
  };
}

const EmptyState = ({ icon, title, description, action }: EmptyStateProps) => (
  <div className="flex flex-col items-center justify-center py-16 text-center">
    {icon && <div className="mb-4 opacity-40">{icon}</div>}
    <h2 className="text-xl font-bold text-gray-800 mb-2">{title}</h2>
    {description && (
      <p className="text-gray-600 mb-4">{description}</p>
    )}
    {action && (
      <button onClick={action.onClick} className="text-primary hover:underline">
        {action.label} â†’
      </button>
    )}
  </div>
);
```

### 7.3 ìƒí™©ë³„ Empty State

#### ëª©ë¡ì´ ë¹„ì–´ìˆì„ ë•Œ

```tsx
<EmptyState
  icon={<FileIcon className="w-16 h-16" />}
  title="ê¸°ë¡ëœ ê±°ë˜ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤"
  description="ì´ ê¸°ê°„ì—ëŠ” ê²°ì œ ë°ì´í„°ê°€ ìˆ˜ì§‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
/>
```

#### ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ì„ ë•Œ

```tsx
<EmptyState
  icon={<SearchIcon className="w-16 h-16" />}
  title="ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤"
  description="ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë¡œ ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”"
/>
```

#### ì²« ì‚¬ìš© ì‹œ

```tsx
<EmptyState
  icon={<SparklesIcon className="w-16 h-16" />}
  title="ì•„ì§ ë“±ë¡ëœ ê³„ì •ì´ ì—†ì–´ìš”"
  description="ì²« ë²ˆì§¸ ê³„ì •ì„ ë“±ë¡í•˜ê³  ì§€ì¶œ ì¶”ì ì„ ì‹œì‘í•˜ì„¸ìš”"
  action={{
    label: "ê³„ì • ë“±ë¡í•˜ê¸°",
    onClick: () => navigate("/onboarding"),
  }}
/>
```

### 7.4 ë‚ ì§œ/ê¸°ê°„ë³„ Empty State

íŠ¹ì • ê¸°ê°„ ë°ì´í„°ê°€ ì—†ì„ ë•Œ ê¸ì •ì ìœ¼ë¡œ í‘œí˜„:

```tsx
// ì§€ì¶œì´ ì—†ëŠ” ë‚ 
<EmptyState
  icon={<WalletIcon className="w-16 h-16" />}
  title="ì´ ë‚ ì€ ì§€ê°‘ì´ ì‰¬ëŠ” ë‚ ! ğŸ’¤"
  description="êµ¬ë§¤ ê¸°ë¡ì´ ì—†ì–´ìš”. ì ˆì•½í•œ ë‹¹ì‹ , ë©‹ì ¸ìš” âœ¨"
/>
```

---

## 8. ë°±ì—…ê³¼ ë³µì›

### 8.1 ë°±ì—… ì „ëµ

#### ìˆ˜ë™ ë°±ì—…

```rust
#[tauri::command]
fn backup_database(
    app_handle: AppHandle,
    state: State<AppState>,
    backup_dir: Option<String>,
) -> Result<String, String> {
    let source_path = configured_db_path(&app_handle, &state)?
        .ok_or("DBê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")?;
    
    // ë°±ì—… ë””ë ‰í† ë¦¬ ê²°ì •
    let backup_dir = backup_dir
        .map(PathBuf::from)
        .unwrap_or_else(|| source_path.parent().unwrap().to_path_buf());
    
    // ë°±ì—… íŒŒì¼ëª… ìƒì„±
    let source_name = source_path.file_stem().unwrap().to_string_lossy();
    let timestamp = Utc::now().format("%Y%m%d-%H%M%S");
    let backup_name = format!("{}.backup-{}.db", source_name, timestamp);
    let backup_path = backup_dir.join(&backup_name);
    
    // SQLite VACUUM INTOë¡œ ìµœì í™”ëœ ë°±ì—…
    let conn = Connection::open(&source_path).map_err(|e| e.to_string())?;
    conn.execute(&format!("VACUUM INTO '{}'", backup_path.display()), [])
        .map_err(|e| e.to_string())?;
    
    Ok(backup_path.to_string_lossy().to_string())
}
```

#### ìë™ ë°±ì—… (ì•± ì‹œì‘ ì‹œ)

```rust
fn auto_backup_if_needed(app_handle: &AppHandle, db_path: &Path) -> Result<(), String> {
    let backup_interval_days = 7; // ì„¤ì •ì—ì„œ ì½ì–´ì˜¬ ìˆ˜ ìˆìŒ
    
    // ë§ˆì§€ë§‰ ë°±ì—… ì‹œê°„ í™•ì¸
    let last_backup = get_setting(db_path, "last_backup_at")?;
    if let Some(last) = last_backup {
        let last_date = DateTime::parse_from_rfc3339(&last)
            .map_err(|e| e.to_string())?;
        let days_since = Utc::now().signed_duration_since(last_date).num_days();
        if days_since < backup_interval_days {
            return Ok(()); // ë°±ì—… ë¶ˆí•„ìš”
        }
    }
    
    // ë°±ì—… ì‹¤í–‰
    let backup_dir = app_handle.path().app_data_dir()?.join("backups");
    fs::create_dir_all(&backup_dir)?;
    
    let backup_path = create_backup(db_path, &backup_dir)?;
    
    // ë°±ì—… ì‹œê°„ ê¸°ë¡
    set_setting(db_path, "last_backup_at", &Utc::now().to_rfc3339())?;
    
    // ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ (ìµœê·¼ 5ê°œë§Œ ìœ ì§€)
    cleanup_old_backups(&backup_dir, 5)?;
    
    Ok(())
}
```

### 8.2 ë³µì›

```rust
#[tauri::command]
fn restore_database(
    app_handle: AppHandle,
    state: State<AppState>,
    backup_path: String,
) -> Result<DbStatus, String> {
    let backup_path = PathBuf::from(backup_path);
    if !backup_path.exists() {
        return Err("ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.".into());
    }
    
    // ê¸°ì¡´ DB ê²½ë¡œ
    let current_path = configured_db_path(&app_handle, &state)?
        .ok_or("í˜„ì¬ DBê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")?;
    
    // í˜„ì¬ DB ë°±ì—… (ë³µì› ì‹¤íŒ¨ ëŒ€ë¹„)
    let temp_backup = current_path.with_extension("restore-temp.db");
    fs::copy(&current_path, &temp_backup).map_err(|e| e.to_string())?;
    
    // ë°±ì—… íŒŒì¼ë¡œ ë³µì›
    match fs::copy(&backup_path, &current_path) {
        Ok(_) => {
            // ì„ì‹œ ë°±ì—… ì‚­ì œ
            let _ = fs::remove_file(&temp_backup);
            
            // ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰ (ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸)
            run_migrations(&current_path)?;
            
            build_status(&current_path, true)
        }
        Err(e) => {
            // ë³µì› ì‹¤íŒ¨ ì‹œ ì›ë³µ
            let _ = fs::copy(&temp_backup, &current_path);
            let _ = fs::remove_file(&temp_backup);
            Err(format!("ë³µì› ì‹¤íŒ¨: {}", e))
        }
    }
}
```

### 8.3 ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°

CSVë‚˜ JSONìœ¼ë¡œ ë°ì´í„° ë‚´ë³´ë‚´ê¸°:

```rust
#[tauri::command]
fn export_to_json(
    app_handle: AppHandle,
    state: State<AppState>,
    table_name: String,
    output_path: String,
) -> Result<usize, String> {
    let db_path = configured_db_path(&app_handle, &state)?
        .ok_or("DBê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")?;
    
    let conn = Connection::open(&db_path).map_err(|e| e.to_string())?;
    
    // í…Œì´ë¸” ë°ì´í„° ì¡°íšŒ
    let mut stmt = conn.prepare(&format!("SELECT * FROM {}", table_name))
        .map_err(|e| e.to_string())?;
    
    let column_names: Vec<String> = stmt.column_names().iter().map(|s| s.to_string()).collect();
    
    let rows: Vec<serde_json::Value> = stmt
        .query_map([], |row| {
            let mut obj = serde_json::Map::new();
            for (i, col) in column_names.iter().enumerate() {
                let val = row.get_ref(i)?;
                let json_val = match val {
                    ValueRef::Null => serde_json::Value::Null,
                    ValueRef::Integer(i) => json!(i),
                    ValueRef::Real(f) => json!(f),
                    ValueRef::Text(t) => json!(String::from_utf8_lossy(t)),
                    ValueRef::Blob(b) => json!(base64::encode(b)),
                };
                obj.insert(col.clone(), json_val);
            }
            Ok(serde_json::Value::Object(obj))
        })
        .map_err(|e| e.to_string())?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| e.to_string())?;
    
    let count = rows.len();
    let output = serde_json::to_string_pretty(&rows).map_err(|e| e.to_string())?;
    fs::write(&output_path, output).map_err(|e| e.to_string())?;
    
    Ok(count)
}
```

---

## 9. Tauri ì»¤ë§¨ë“œ ì„¤ê³„

### 9.1 DB ìƒíƒœ ê´€ë¦¬ ì»¤ë§¨ë“œ

```rust
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct DbStatus {
    configured: bool,      // config.jsonì— ê²½ë¡œê°€ ì„¤ì •ë¨
    path: String,          // í˜„ì¬ DB ê²½ë¡œ
    exists: bool,          // íŒŒì¼ì´ ì‹¤ì œë¡œ ì¡´ì¬í•¨
    size_bytes: Option<u64>,
    tables: Vec<String>,
}

// DB ìƒíƒœ ì¡°íšŒ
#[tauri::command]
fn get_db_status(app_handle: AppHandle, state: State<AppState>) -> Result<DbStatus, String>;

// ìƒˆ DB ì´ˆê¸°í™”
#[tauri::command]
fn init_db(
    app_handle: AppHandle,
    state: State<AppState>,
    path: Option<String>,  // Noneì´ë©´ ê¸°ë³¸ ê²½ë¡œ
) -> Result<DbStatus, String>;

// ê¸°ì¡´ DB ë¶ˆëŸ¬ì˜¤ê¸°
#[tauri::command]
fn load_existing_db(
    app_handle: AppHandle,
    state: State<AppState>,
    path: String,
) -> Result<DbStatus, String>;

// ë¡œê·¸ì•„ì›ƒ (DB ì—°ê²° í•´ì œ)
#[tauri::command]
fn logout(app_handle: AppHandle, state: State<AppState>) -> Result<(), String>;
```

### 9.2 CRUD ì»¤ë§¨ë“œ íŒ¨í„´

```rust
// ëª©ë¡ ì¡°íšŒ
#[tauri::command]
fn list_users(
    app_handle: AppHandle,
    state: State<AppState>,
) -> Result<UserListResponse, String>;

// ë‹¨ê±´ ì¡°íšŒ
#[tauri::command]
fn get_user(
    app_handle: AppHandle,
    state: State<AppState>,
    id: String,
) -> Result<User, String>;

// ìƒì„±
#[tauri::command]
fn create_user(
    app_handle: AppHandle,
    state: State<AppState>,
    alias: String,
    // ... ê¸°íƒ€ í•„ë“œ
) -> Result<String, String>;  // ìƒì„±ëœ ID ë°˜í™˜

// ìˆ˜ì •
#[tauri::command]
fn update_user(
    app_handle: AppHandle,
    state: State<AppState>,
    id: String,
    alias: Option<String>,
    // ... ìˆ˜ì • ê°€ëŠ¥í•œ í•„ë“œ
) -> Result<(), String>;

// ì‚­ì œ
#[tauri::command]
fn delete_user(
    app_handle: AppHandle,
    state: State<AppState>,
    id: String,
) -> Result<(), String>;
```

### 9.3 UPSERT íŒ¨í„´ (ë°ì´í„° ë™ê¸°í™”)

ì™¸ë¶€ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•  ë•Œ ì¤‘ë³µì„ ì²˜ë¦¬í•˜ëŠ” íŒ¨í„´:

```rust
#[tauri::command]
fn save_payment(
    app_handle: AppHandle,
    state: State<AppState>,
    payment: PaymentInput,
) -> Result<i64, String> {
    let conn = get_connection(&app_handle, &state)?;
    
    // UPSERT: ì¡´ì¬í•˜ë©´ ì—…ë°ì´íŠ¸, ì—†ìœ¼ë©´ ì‚½ì…
    conn.execute(
        r#"
        INSERT INTO tbl_payment (user_id, pay_id, amount, paid_at, created_at, updated_at)
        VALUES (?1, ?2, ?3, ?4, datetime('now'), datetime('now'))
        ON CONFLICT(user_id, pay_id) DO UPDATE SET
            amount = excluded.amount,
            paid_at = excluded.paid_at,
            updated_at = datetime('now')
        "#,
        params![payment.user_id, payment.pay_id, payment.amount, payment.paid_at],
    ).map_err(|e| e.to_string())?;
    
    // ì‚½ì…/ì—…ë°ì´íŠ¸ëœ í–‰ì˜ ID ë°˜í™˜
    Ok(conn.last_insert_rowid())
}
```

### 9.4 ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€

```rust
// ê²°ê³¼ íƒ€ì… í‘œì¤€í™”
type CmdResult<T> = Result<T, String>;

// í—¬í¼ í•¨ìˆ˜ë¡œ ê³µí†µ ê²€ì¦
fn get_connection(
    app_handle: &AppHandle,
    state: &State<AppState>,
) -> Result<Connection, String> {
    let path = configured_db_path(app_handle, state)?
        .ok_or_else(|| "DBê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.".to_string())?;
    
    if !path.exists() {
        return Err("DB íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.".to_string());
    }
    
    Connection::open(&path).map_err(|e| e.to_string())
}
```

---

## 10. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 10.1 ë¯¼ê° ë°ì´í„° ë³´í˜¸

```sql
-- ì¸ì¦ ì •ë³´ëŠ” ë³„ë„ í…Œì´ë¸”ë¡œ ë¶„ë¦¬
CREATE TABLE IF NOT EXISTS tbl_credential (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    key TEXT NOT NULL,
    value TEXT NOT NULL,  -- ì•”í˜¸í™” ê¶Œì¥
    -- ...
);
```

### 10.2 SQL ì¸ì ì…˜ ë°©ì§€

í•­ìƒ íŒŒë¼ë¯¸í„° ë°”ì¸ë”© ì‚¬ìš©:

```rust
// ì¢‹ì€ ì˜ˆ
conn.execute(
    "SELECT * FROM tbl_user WHERE id = ?1",
    [user_id],
)?;

// ë‚˜ìœ ì˜ˆ (ì ˆëŒ€ ê¸ˆì§€)
conn.execute(
    &format!("SELECT * FROM tbl_user WHERE id = '{}'", user_id),
    [],
)?;
```

### 10.3 íŒŒì¼ ê¶Œí•œ

- DB íŒŒì¼ì€ ì‚¬ìš©ì ì „ìš© ë””ë ‰í† ë¦¬ì— ì €ì¥
- ì•± ë°ì´í„° ë””ë ‰í† ë¦¬ëŠ” OSê°€ ì ì ˆí•œ ê¶Œí•œì„ ì„¤ì •
- ì•”í˜¸í™”ê°€ í•„ìš”í•œ ê²½ìš° SQLCipher ì‚¬ìš© ê³ ë ¤

### 10.4 ë°ì´í„° ë¬´ê²°ì„±

```sql
-- Foreign Key í™œì„±í™” (ë§¤ ì—°ê²°ë§ˆë‹¤)
PRAGMA foreign_keys = ON;

-- ì •ê¸°ì  ë¬´ê²°ì„± ê²€ì‚¬
PRAGMA integrity_check;

-- íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì›ìì„± ë³´ì¥
BEGIN TRANSACTION;
-- ì—¬ëŸ¬ ì‘ì—…
COMMIT;
```

---

## ë¶€ë¡: í”„ë¡œì íŠ¸ë³„ ì ìš© ì˜ˆì‹œ

### ì§€ì¶œ íƒì • (ì´ í”„ë¡œì íŠ¸)

- **DB íŒŒì¼**: `tauti.db`
- **ì£¼ìš” í…Œì´ë¸”**: `tbl_user`, `tbl_credential`, `tbl_naver_payment`, `tbl_coupang_payment`
- **íŠ¹ì§•**: ì™¸ë¶€ API ë°ì´í„° ìˆ˜ì§‘, UPSERT íŒ¨í„´ í™œìš©

### ê°€ê³„ë¶€ ì•±

- **DB íŒŒì¼**: `ledger.db`
- **ì£¼ìš” í…Œì´ë¸”**: `tbl_account`, `tbl_entry`, `tbl_tag`, `tbl_history`
- **íŠ¹ì§•**: ë³€ê²½ ì´ë ¥ ì¶”ì , íƒœê·¸ ê¸°ë°˜ ë¶„ë¥˜

### í•  ì¼ ê´€ë¦¬ ì•±

- **DB íŒŒì¼**: `tasks.db`
- **ì£¼ìš” í…Œì´ë¸”**: `tbl_task`, `tbl_project`, `tbl_label`
- **íŠ¹ì§•**: ê³„ì¸µ êµ¬ì¡°, ìƒíƒœ ì „ì´

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸

ìƒˆ í”„ë¡œì íŠ¸ì—ì„œ ì´ ê°€ì´ë“œë¥¼ ì ìš©í•  ë•Œ í™•ì¸í•  í•­ëª©:

- [ ] `app_data_dir()` ê¸°ë°˜ ê¸°ë³¸ ì €ì¥ ê²½ë¡œ ì„¤ì •
- [ ] `config.json`ê³¼ ë°ì´í„° DB ë¶„ë¦¬
- [ ] `tbl_setting` í…Œì´ë¸”ë¡œ ì•± ì„¤ì • ê´€ë¦¬
- [ ] ëª¨ë“  í…Œì´ë¸”ì— `created_at`, `updated_at` ì»¬ëŸ¼
- [ ] `CREATE IF NOT EXISTS` íŒ¨í„´ìœ¼ë¡œ ë©±ë“±í•œ ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] DB ë¯¸ì„¤ì • ì‹œ ì˜¨ë³´ë”© UI
- [ ] ë°ì´í„° ì—†ìŒ ì‹œ Empty State UI
- [ ] íŒŒë¼ë¯¸í„° ë°”ì¸ë”©ìœ¼ë¡œ SQL ì¸ì ì…˜ ë°©ì§€
- [ ] `PRAGMA foreign_keys = ON` í™œì„±í™”
- [ ] ë°±ì—…/ë³µì› ê¸°ëŠ¥ êµ¬í˜„ (ë˜ëŠ” ê³„íš)

